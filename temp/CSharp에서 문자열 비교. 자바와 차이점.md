---
title: CSharp에서 문자열 비교. 자바와 차이점
created: 2025-08-20 10:22
alias:
tags:
---
과거에 문자열을 연산자로 직접 비교하지 말라고 배웠는데 직접 비교연산자로 문자열의 같음을 판별하는지.

현대 C#의 `string` 타입에 한해서는 
== !=를 사용하는 것이 더 자연스럽고 권장되는 방식이다.

따라서 `.Where(key => key != "EMP_CODE_ORIGIN")` 코드는 **전혀 문제없고 아주 좋은 코드**입니다.

왜 과거에 문자열을 연산자로 직접 비교하지 말라고 배웠는지, 그리고 지금은 왜 괜찮은지 그 배경을 이해하면 명확해집니다.

---

### ## 왜 그렇게 배웠을까요? (과거의 지식)

문자열 비교에 == 를 직접 쓰지 말라는 조언의 주된 이유는 두 가지

1. **Java의 영향**: Java에서 == 연산자는 두 객체의 **메모리 주소(참조)를 비교**합니다. 
2. 따라서 내용이 똑같은 두 문자열이라도 서로 다른 객체라면 == 비교는 `false`를 반환합니다. 
3. Java에서는 문자열의 **내용을 비교**하기 위해 반드시 `.equals()` 메서드를 사용해야 합니다. 
4. 많은 개발자들이 Java의 이 규칙에 익숙하기 때문에 C#에서도 동일한 관습을 따르곤 했습니다.
    
5. **C#의 참조 타입**: C#에서도 `string`은 클래스(class)이므로 **참조 타입(reference type)** 입니다. 
6. 원칙적으로 참조 타입에 == 를 사용하면 Java처럼 메모리 주소를 비교하는 것이 맞습니다.
    

**하지만 C#의 `string` 타입은 특별한 대우를 받도록 설계되었습니다.**

### ## C#에서 == != 연산이 괜찮은 이유

C#의 `string` 타입은 == 와 != 연산자가 **값(value)을 비교하도록 재정의(overload)되어 있습니다.** 
즉, 개발자가 `string a == string b` 코드를 작성하면, 컴파일러는 두 문자열의 메모리 주소가 아닌, 실제 문자열의 내용이 같은지를 비교하는 코드로 처리해 줍니다.

이는 C# 언어 설계자들이 문자열 비교가 매우 흔한 작업임을 인지하고, 개발자가 다른 참조 타입과 달리 좀 더 직관적으로 코드를 작성할 수 있도록 배려한 결과입니다.


### ## 그럼 `.Equals()`는 언제 사용할까요?

그렇다고 `.Equals()` 메서드가 쓸모없는 것은 아닙니다. `==` 연산자가 처리하지 못하는 **더 상세하고 명시적인 비교**가 필요할 때 사용합니다.

| 비교 방식           | 사용 사례                                                                              | 예시 코드                                                               |
| --------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| ** == 또는 != **  | **대소문자를 구분**하는 <br>가장 간단하고 직관적인 **값 비교**가 필요할 때. <br>코드가 간결해지고 가독성이 높아집니다.         | `if (key == "EMP_CODE_ORIGIN") { ... }`                             |
| **`.Equals()`** | **대소문자를 무시**하거나, <br>특정 **문화권(culture)의 규칙**에 따라 비교해야 할 때 등 <br>명시적인 비교 옵션이 필요할 때. | `key.Equals("emp_code_origin", StringComparison.OrdinalIgnoreCase)` |


`StringComparison` 열거형은 다음과 같은 유용한 옵션을 제공합니다.

- `OrdinalIgnoreCase`: **가장 빠른 성능**. 대소문자를 무시하며, 언어 규칙과 상관없이 문자의 이진(binary) 값을 비교합니다.
    
- `CurrentCultureIgnoreCase`: 현재 시스템의 문화권 규칙에 따라 대소문자를 무시하며 비교합니다.
    
- `InvariantCultureIgnoreCase`: 특정 문화권에 종속되지 않는 고정된 규칙으로 대소문자를 무시하며 비교합니다.
    

### ## 결론

> **알고 계셨던 지식은 "객체는 참조로 비교된다"는 프로그래밍의 중요한 원칙이며, 이는 여전히 유효합니다. 다만 C#의 `string`은 그 원칙의 예외적인 편의를 제공하도록 특별하게 설계되었을 뿐입니다.**

따라서 질문하신 `Where` 조건문에서 `key != "EMP_CODE_ORIGIN"`과 같이 `!=` 연산자를 사용하는 것은 대소문자를 구분하는 명확한 의도를 가장 간결하게 표현한 **현대적이고 올바른 C# 스타일**입니다. 만약 대소문자를 구분하지 않고 비교해야 했다면, 그때는 `.Equals()`를 사용하는 것이 맞습니다.

C#

```CSharp 
// 대소문자 구분 없이 "EMP_CODE_ORIGIN"이 아닌 키를 필터링할 경우
List<string> keyList = hashtable.Keys
                                .Cast<string>()
                                .Where(key => !key.Equals("EMP_CODE_ORIGIN", StringComparison.OrdinalIgnoreCase))
                                .ToList();
```


