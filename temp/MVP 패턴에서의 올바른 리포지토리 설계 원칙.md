---
title: MVP 패턴에서의 올바른 리포지토리 설계 원칙
created: 2025-08-27 04:16
alias:
tags:
---
MVP(Model-View-Presenter) 패턴과 리포지토리(Repository) 패턴을 함께 사용할 때, 
각 컴포넌트의 역할을 명확히 구분하는 것은 테스트 가능하고 유지보수하기 쉬운 애플리케이션을 만드는 데 매우 중요합니다. 
이 문서는 리포지토리를 DTO, 뷰, 테이블과 어떻게 연관 지어 설계해야 하는지에 대한 핵심 원칙을 정리합니다.

## 1. 리포지토리 vs DTO: 역할의 분리

> **질문: "리포지토리는 DTO당 하나씩 필요한가요?"**

**결론: 아닙니다. 리포지토리는 도메인 엔티티(특히, 애그리거트 루트)당 하나를 생성합니다.**

- **리포지토리(Repository)의 역할**: 
  **도메인 모델의 영속성(Persistence) 관리**가 주 목적입니다. 
  데이터베이스 같은 저장소에서 비즈니스 규칙을 포함한 완전한 엔티티 객체를 가져오거나(`Find`), 저장(`Save`)하는 책임을 집니다. 
  '객체 창고 관리자'에 비유할 수 있습니다.
    
- **DTO(Data Transfer Object)의 역할**: 
  **계층 간 데이터 전송**을 위한 단순한 데이터 컨테이너입니다. 
  특히 UI(View)에 필요한 데이터만 선택적으로 보여주거나 외부로부터 데이터를 받을 때 사용됩니다. 
  '배송 명세서'나 '주문서 양식'에 비유할 수 있습니다.
    

하나의 `User` 엔티티는 여러 DTO(`UserSummaryDto`, `UserDetailDto` 등)로 변환될 수 있습니다. 
이 모든 DTO는 단 하나의 `IUserRepository`를 통해 조회된 `User` 엔티티를 가공하여 만들어집니다.

**핵심 원칙: 리포지토리는 비즈니스 모델(엔티티)을 중심으로, DTO는 화면 표시를 중심으로 설계합니다.**

## 2. 리포지토리 vs 뷰: 명확한 경계

> **질문: "뷰 하나당 리포지토리 하나씩 하는 것도 아닌가요?"**

**결론: 절대 아닙니다. 뷰와 리포지토리는 서로의 존재를 알아서는 안 됩니다.**

뷰와 리포지토리는 아키텍처의 양쪽 끝에 위치하며, 
**프레젠터(Presenter)**라는 중개자를 통해서만 소통해야 합니다.

올바른 데이터 흐름:

View ↔ Presenter ↔ Repository ↔ Database

만약 뷰가 리포지토리를 직접 참조하면 다음과 같은 문제가 발생합니다.

- **관심사 분리 원칙 위배**: 뷰가 데이터 접근 로직을 알게 되어 역할이 모호해집니다.
    
- **테스트의 어려움**: UI(View)를 테스트하기 위해 데이터베이스 연결까지 고려해야 하므로 단위 테스트가 불가능해집니다.
    
- **재사용성 저하**: 여러 뷰에서 공통으로 사용할 수 있는 리포지토리 로직이 중복됩니다.
    

**핵심 원칙: 뷰는 프레젠터에게 요청하고, 프레젠터가 리포지토리에 요청하는 흐름을 반드시 지켜야 합니다.**

## 3. 리포지토리 vs 테이블: 애그리거트 루트 중심 설계

> **질문: "그러면 테이블당 리포지토리 하나인가요?"**

**결론: 가장 근접하지만, 더 정확한 원칙은 '애그리거트 루트(Aggregate Root)'당 하나입니다.**

- **'1 테이블 = 1 리포지토리'가 맞는 경우**: `Users`, `Products`처럼 테이블 하나가 독립적인 비즈니스 개념(애그리거트 루트)을 나타낼 때는 이 규칙이 잘 맞습니다.
    
- **'1 테이블 = 1 리포지토리'가 틀리는 경우**: `Orders`와 `OrderItems` 테이블처럼 여러 테이블이 모여 하나의 비즈니스 개념을 형성할 때는 규칙이 달라집니다.
    
    - `Order`는 `OrderItems` 없이 존재할 수 있지만, `OrderItems`는 `Order` 없이는 의미가 없습니다.
        
    - 이때 비즈니스 트랜잭션의 중심이 되는 `Order`가 **애그리거트 루트**입니다.
        
    - 따라서 `IOrderRepository`만 만들고, `OrderItems`는 `Order` 객체를 통해 관리합니다. `IOrderItemRepository`는 만들지 않습니다.
        

**핵심 원칙: 리포지토리는 데이터베이스 테이블 구조가 아닌, 논리적인 비즈니스 데이터의 단위(애그리거트 루트)를 기준으로 생성합니다.**

## 4. 실전 예제: 직원-프로젝트 관리 시스템

> **상황**: 직원정보, 프로젝트목록, 프로젝트 기간/원가, 프로젝트 참여인력, 요구기술, 직원별 목표 등 여러 테이블이 존재할 때 리포지토리 구성 방법

이 경우, 핵심 비즈니스 단위(애그리거트 루트)는 **'직원(Employee)'**과 **'프로젝트(Project)'**입니다.

#### 추천 리포지토리 구성

1. **`IEmployeeRepository`**:
    
    - 관리 대상: `직원정보`, `직원별 년단위 목표정보`
        
    - 이유: 직원의 목표는 직원에 종속된 정보이기 때문입니다.
        
2. **`IProjectRepository`**:
    
    - 관리 대상: `프로젝트목록`, `프로젝트 기간/원가정보`, `프로젝트 참여직원 정보`, `프로젝트 요구기술`
        
    - 이유: 기간, 원가, 참여인력 등은 모두 특정 프로젝트가 있어야만 의미를 갖는 하위 정보이기 때문입니다.
        

이 설계는 `Project` 객체 하나를 통해 관련된 모든 정보를 하나의 트랜잭션으로 일관성 있게 관리할 수 있게 해줍니다.
