---
title: 부동소수점 트러블슈팅. 0.7이 69%가 된 경우
created: 2025-02-20 09:54
alias:
tags:
---
프로그래밍에서 부동소수점 수는 정확한 값이 아닌 근사치로 저장됩니다. 이 때문에 0.7과 같이 이진 표현이 정확하지 않은 값에 연산을 수행하면 예상과 다른 결과가 나올 수 있습니다.

### 문제 원인

- **부동소수점 표현의 한계**
    - 컴퓨터는 실수를 이진법으로 저장하며, 0.7과 같은 값은 정확하게 표현되지 않고 근사치로 저장됩니다.
- **연산 오차 발생**
    - 0.7에 100을 곱할 때, 이론상 70이 되어야 하지만 실제로는 69.9999...와 같이 미세한 오차가 발생합니다.
- **형변환의 트렁케이션(truncation)**
    - `int`로의 형변환은 소수점 이하를 버리는 방식이기 때문에 69.9999...가 69로 잘려나갑니다.

### 해결 방법

- **반올림 적용**
    - 연산 후 바로 `int`로 형변환하기보다는, 반올림 함수를 사용하여 결과를 올바르게 조정한 후 형변환합니다.
    - 예:
        
        ```csharp
        int percentage = (int)Math.Round(a * 100);
        ```
        
- **정밀도 높은 자료형 사용**
    - 금융 계산 등 높은 정밀도가 요구되는 경우 `decimal` 타입이나 고정 소수점(fixed point) 방식을 사용하는 것도 방법입니다.

### 요약 포인트

- 부동소수점 수는 근사치로 저장되므로 0.7 × 100 연산에서 미세한 오차가 발생함.
- 이 오차로 인해 소수점 이하를 버리는 형변환 시 69가 결과로 나옴.
- 반올림 적용 및 정밀도 높은 자료형 사용으로 문제를 해결할 수 있음.

### 정수형으로의 명시적 형변환과 문자열 출력에서 다르게
- **내부적 반올림 처리**
    - 문자열로 출력할 때, `float.ToString()` 메서드는 기본적으로 값을 **적절하게 반올림**하여 표현합니다.
    - 이 때문에 69.9999...가 문자열로 변환될 때는 "70"과 같이 보정된 값으로 표시됩니다.
- **형변환 없이 계산**
    - 코드에서는 int로 변환하지 않고, float 값에 100을 곱한 결과를 바로 문자열 내에 삽입하기 때문에, 반올림 효과로 기대하는 값에 가까운 결과가 출력됩니다.


