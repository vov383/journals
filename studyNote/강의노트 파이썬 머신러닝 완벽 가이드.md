---
title: 강의노트 파이썬 머신러닝 완벽 가이드
created: 2025-07-24 10:48
alias:
tags:
---
## 섹션 1. 강의 소개

##섹션 2. 머신러닝 개념
### 머신러닝 필요성 
특징들을 if else 조건으로 구분하기 어렵다. 너무 많이 필요.

일반적인 알고리즘은 
input a, b
규칙을 잘 만들어서
output c를 얻기.

머신러닝은
input a, b
output c 
여러 세트를 주고 규칙을 컴퓨터가 만들도록

for 복잡한 문제 해결
데이터의 패턴 학습. 예측 수행
예측 분석 => 새로운 의미와 인사이트 발굴 => 이익 실현


### 머신러닝 유형
분류 기준 답 유무
feature 기반
문제 답
#### 지도학습
종류
- 분류
- 회귀
- 추천 시스템
- 시각/음성 감지/인지


#### 비지도학습
종류
- 군집화(클러스터링)
- 차원축소
- 토픽 모델링, 문서 군집화

![[../../noGitSync/Attachments/Pasted image 20250724114445.png]]

### 머신러닝 단점
데이터 의존적 각비지 인 가비지 아웃
학습 데이터에 과적합, 실제 문제 해결에 적용 어렵
머신러닝 블랙박스. 

**데이터만 집어넣으면 자동으로 최적화된 결과를 도출할 것이라는 환상**
직접 개발자가 만든 코드보다 정확도가 떨어질 수도

좋은 데이터 필요.
데이터의 특성, 최적 알고리즘, 파라미터 구성 능력 요구

구글 페이스북의 데이터로 최적화된 머신러닝 모델을 다른 회사가 이길 수 있나

머신러닝 모델을 가지고 있느냐에 따라 기업의 경쟁력이 좌우될 것

### 파이썬 기반 머신러닝 장점, 구성요소
#### R과 파이썬 비교
##### R 장점
통계 분석에 능함.

##### 파이썬 장점
개발언어
직관적 문법
객체지향, 함수형 모두 포괄
다양한 라이브러리

인터프리터 언어 특성상 느리지만 쉽고 유연함.

데스크탑, 서버, 네트어크, 시스템, iot 등 다양한 영역에서 사용되고 있음.

머신러닝 서비스를 만들면
서비스 모듈로 만들기 좋음.

### 파이썬 머신러닝을 위한 s/w 설치
아나콘다 설치. 
기존 base환경의 라이브러리가 너무 많음. 시간 오래걸림
아나콘다 지우고 새로 설치하자.

파이썬 3.9 버전
가상환경을 새로 만들자. 

libmamba 설치하고
```

```


```
conda create -n ml_env -c conda-forge --solver=libmamba python=3.9 scikit-learn=1.0.2 xgboost=1.5.0 lightgbm=3.3.2 pandas notebook
```

ml_env

```
conda activate ml_env
```

```

```

### 사이킷런 업그레이드 수행 및 XGBoost와 LightGBM 설치

#### xgboost 설치
1.5.0


visual studio installer 설치

c++을 사용한 데스크톱 개발 설치

#### LightGBM 설치
3.3.2



### 주피터 노트북 사용법과 넘파이/판다스 필요성

#### 주피터 노트북 사용법
대화형 파이썬 툴
전체 프로그램에서 특정 코드 영역별로 개별 수행 지원
영역별 코드 이해 명확

공책. 중요 코드 단위로 설명 적어.
셀 안에 코드 실행. 겨로가를 볼 수 있게. 직관적으로 해당 코드 역할 이해

주피터 노트북 실행.
콘솔의 역할.
실행 pc 로컬호스트 8888에 웹 서버 실행.
웹서버에 자동 접속

컴퓨터의 사용자 홈디렉토리로 가.
new 버튼으로 새로운 파이썬 개발 환경 커널을 만들어.



###### 주피터 노트북의 작업 효율을 극적으로 높여주는 유용한 단축키들을 모아서 정리
![[journals/temp/주피터 노트북의 작업 효율을 극적으로 높여주는 유용한 단축키들을 모아서 정리]]


ctrl + enter로 셀 실행
alt + enter로 셀 실행하고 다음 셀 생성

esc하고 명령모드 전환 후에 m 으로 마크다운 모드로 전환

esc하고 y로 코드 모드로 전환


상단바 edit > clear cell output, clear outputs of all cells

상단바 kernel > restart and clear all outputs로 다시 처음부터 실행하는 상태로 만들어.

상단바 kernel > interrupt로 무한루프같은 상황에 빠져나오기

file > duplicate로 노트의 카피 만들고

file > save로 노트북 저장


차시예고
![[attaches/Pasted image 20250728135526.png]]



numpy는 api 방대함.
document도 많이 없고

pandas는 다양한 document 있음.

numpy가 시간 많이 잡아 먹을 것.

ml을 위해 numpy, pandas에 너무 많은 시간을 들이는 건 반대.

전문적으로 공부하는 건 ml 하면서 하는게

numpy, pandas에 대한 좋은 얇은 책, 별도 강좌도 있더라.

코드 개발하면서 api 이것 저것 사용해보면서 익히는 방향으로.

ml과 numpy, pandas 함께 배우기.

### 넘파이
ndarray : n차원(dimension) 배열(array) 객체

중첩된 리스트.
1차원 배열은 그냥 배열(선)

2차원 배열은 1차원 배열(선) n개

3차원 배열은 2차원 배열(면적)이 n개

4차원 배열은 3차원 배열이 n개

![[../../noGitSync/Attachments/Pasted image 20250728142157.png]]

한 차원 밑에 있는 요소들을 원소로 가지는 형태의 배열이 ndarray다.

ndarray 사용.

List 는 대용량 데이터 처리하기 힘듬

numpy는 벡터 프로세싱이 돼서 금방 처리 가능.

![[attaches/Pasted image 20250728142925.png]]


반드시 알고 가야하는 차원 shape

ndarray 형태(Shap)와 차원

ndarray.ndim 속성으로 차원 알 수 있어도 ndarray.shape를 주로 쓴다. 
ndarray.shape.len 하면 나옴.

tuple 맨 마지막에 ,가 들어있으면 무조건 1차원.
![[../../noGitSync/Attachments/Pasted image 20250728143531.png]]


ndarray 타입

다 같은 타입이어야 한다.
int, float 같이 담으면 메모리 사이즈 큰 float으로 자동 형변환.
ndarray.dtype으로 타입 확인 가능.


![[../../noGitSync/Attachments/Pasted image 20250728143709.png]]


astype()을 이용해서 형변환
대용량 데이터를 ndarray로 만들 때 메모리 절약을 위해 주로 사용.
int를 float으로 형변환.

대용량 데이터 다룰 시 메모리 절약을 위해 특히 형변환 고려

![[attaches/Pasted image 20250728143931.png]]



### ndarray 실습

```python
import numpy as np

list1 = [1, 2, 3]
print('list1 type:', type(list1))
array1 = np.array(list1)
#array1 = np.array([1,2,3])
print('array1 type:',type(array1))
print('array1 array 형태:',array1.shape)

array2 = np.array([[1,2,3],
                  [2,3,4]])
print('array2 type:',type(array2))
print('array2 array 형태:',array2.shape)

array3 = np.array([[1,2,3]])
print('array3 type:',type(array3))
print('array3 array 형태:',array3.shape)
```

array1은 1차원 배열,
array3은 2차원 배열. 
행이 1인 2차원 배열. 이런 경우 주의 필요.

array3에서 행이 1인 것을 주의하라는 의미는 **차원(dimension)과 형태(shape)의 해석**에 대한 것입니다.

### 1차원 배열과 2차원 배열의 구분
제공된 코드를 보면 `array1`은 `[1, 2, 3]`이라는 리스트를 기반으로 생성된 
1차원 배열입니다. 
이 경우 `shape`는 `(3,)`으로 나타나죠. 
이는 요소가 3개인 1차원 배열임을 의미합니다.

`array3`은 `[[1, 2, 3]]`이라는 리스트 안에 또 다른 리스트가 있는 형태로, 
마치 엑셀 시트의 한 행처럼 보입니다. 
이때 `shape`는 `(1, 3)`으로 나타납니다. 
여기서 앞의 `1`은 **행의 개수**를, 뒤의 `3`은 **열의 개수**를 의미합니다.

### 왜 이 부분이 중요할까요?

- **연산 방식의 차이:** NumPy는 배열의 차원과 형태에 따라 연산을 다르게 적용합니다. 예를 들어, 1차원 배열 `(3,)`과 2차원 배열 `(1, 3)`은 시각적으로는 비슷해 보여도, 특정 연산에서는 전혀 다른 결과를 낳을 수 있습니다. 행렬 곱셈이나 브로드캐스팅(broadcasting) 규칙을 적용할 때 이런 차이가 특히 명확해집니다.
    
- **데이터 해석의 오류 방지:** 데이터를 처리할 때, 1차원 데이터로 생각하고 코드를 작성했는데 실제로는 2차원 배열(특히 행이 1개인)이라면 예상치 못한 에러가 발생하거나 잘못된 결과로 이어질 수 있습니다. 예를 들어, 특정 머신러닝 모델의 입력 데이터는 특정 형태를 요구하는 경우가 많습니다. 이때 `(3,)` 형태와 `(1, 3)` 형태를 혼동하면 모델이 데이터를 제대로 처리하지 못할 수 있습니다.
    
- **코드의 명확성:** `array3`처럼 행이 1개인 2차원 배열은 나중에 코드를 볼 때 개발자가 1차원 배열과 혼동하기 쉽습니다. 명확하게 2차원 배열임을 인지하고 코드를 작성해야 합니다.
    

간단히 말해, `(3,)`은 "요소가 3개인 한 줄짜리 데이터"이고, `(1, 3)`은 "행이 1개이고 열이 3개인 표 형태의 데이터"라고 이해하면 됩니다. 둘은 엄연히 다른 형태이며, NumPy를 효율적으로 사용하려면 이러한 차원을 정확히 이해하는 것이 중요합니다.


```python
list2 = [1, 2, 'test']
array2 = np.array(list2)
print(array2, array2.dtype)

list3 = [1, 2, 3.0]
array3 = np.array(list3)
print(array3, array3.dtype)
```

```결과
['1' '2' 'test'] <U21
[1. 2. 3.] float64
```

`U21`은 문자열 의미
int가 float으로 자동 형변환(메모리 큰 쪽으로)


### ndarray axis 축
numpy의 axis가 헷갈린다.
2차원배열의 axis0, axis1에 대해서

단일 원소로 표현될 수 있는 가장 작은 단위. `1, 2, 3, 4`
이게 axis1
그리고 axis1의 요소들이 뭉쳐서 여러 개가 있으면
`[1,2,3,4]`, `[5,6,7,8]`
차원이 하나씩 뒤에서부터 앞으로 감.
이게 axis0

같은 논리로 3차원 배열.
뒤에서부터 생각하자.
가장 기본이 되는 1, 2, 3, 4
이게 axis2,

axis2가 여러 개 있어. 
`[1,2,3,4]`, `[5,6,7,8]`
이게 axis1,

이런 axis1이 다수 있으면
이게 axis0


![[attaches/Pasted image 20250728150045.png]]

4차원을 생각해보자
axis3, axis2, axis1, axis0 이렇게.

2차원배열을 행렬로 말하지만 엄밀히 말하면
행이 아니라 axis0이 된다.
열은 axis1이 된다.

처음에는 헷갈릴 수 있다.

우리가 주로 다루는 차원은 1차원 or 2차원. 외워도 좋다.

3차원은 그리 많이 다루지 않음.

딥러닝을 할 때 3차원을 다루게 될 것.


### ndarray 초기화 방법. 차원 크기 변경 reshape() 이해 01

#### np.arange(10)
0~9까지 10개의 원소를 iteration할 수 있게

np.zeros((3,2), dtype='int32')
`(3,2)`는 튜플.
zeros는 원소를 전부 0으로 채워라.

np.ones((3,2))
ones는 원소를 전부 1로 채워라.
타입을 안 적어서 기본 float64로 채워짐. 

만들어야 할 데이터의 shape을 알고 값은 모를 때 일단 만들기.
로직을 써서 나중에 값이 업데이트 되도록.

![[attaches/Pasted image 20250728150638.png]]

#### reshpae()

reshape(2, 5)
2차원 2x5 ndarray로 변환.

![[attaches/Pasted image 20250728150808.png]]

reshape할 때 처음에 헷갈리는 요소
reshape(-1, 5)

인자에 -1을 부여? 
axis의 크기를 가변적으로.


10개 요소를 reshape(-1,5) 하면 
```
[[0,1,2,3,4]
[5,6,7,8]]
```
(2,5)가 됨.

8개 요소를 reshape(-1,5) 하면? 컴파일에러
```python
array1 = array1 = np.arange(10)  
array1.reshape(4,3)

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[10], line 1
----> 1 array1.reshape(4,3)

ValueError: cannot reshape array of size 10 into shape (4,3)
```
10개를 어떻게 4,3 하라는거니 라고 말한다.


```python
array1 = np.arange(10)
array4 = array1.reshape(-1,4)

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[12], line 2
      1 array1 = np.arange(10)
----> 2 array4 = array1.reshape(-1,4)

ValueError: cannot reshape array of size 10 into shape (4)
```


![[attaches/Pasted image 20250728151134.png]]


#### reshape(-1,1), reshape(-1,)은 다르다

reshape(5, )은 1d

array1d = `[0,1,2,3,4]`일 때
reshape(-1,1)은 2차원. shape는 (5,1)
```
[[0]
[1]
[2]
[3]
[4]]
```

array2d = `[0] [1] [2] [3] [4]`일 때
reshape(-1,)는 무조건 1d로 변환.
shape는 (5, ) `[0, 1, 2, 3, 4]`

머신러닝 API가 인자로 1차원 ndarray를 명확하게 2차원 ndarray로 변환하여 입력하기를 원하거나, 
반대의 경우가 있을 수 있음.

![[attaches/Pasted image 20250728151654.png]]


### numpy indexing 이해. 단일값과 슬라이싱 인덱싱

#### 유형
단일값 가져오기
여러 개의 값 가져오기

slicing
`0:9`
0부터 9개 가져오기.

fancy indexing
`[0, 1, 2]`
위치 인덱스 기반 0, 1, 2 위치에 있는 값 가져오기.

boolean indexing
굉장히 유용
조건을 인덱싱에 걸어.
조건에 맞는 위치 인덱스의 값을 찾아.
true, false값

![[attaches/Pasted image 20250728160335.png]]


#### 단일 값 추출 1d

원본 데이터가 있어.

ndarray 뒤에 `[]`(브레킷)이 들어가.
위치 인덱싱을 하겠다.
array1 = `[1,2,3,4,5,6,7,8,9]`
9개 요소가 있어.
index가 0~8까지

```python
array1[-1]
array1[-2]
```
-1은 맨 뒤.
-2는 맨 뒤에서 2번째.

![[attaches/Pasted image 20250728160628.png]]


```python
# 1에서 부터 9 까지의 1차원 ndarray 생성 
array1 = np.arange(start=1, stop=10)
print('array1:',array1)
# index는 0 부터 시작하므로 array1[2]는 3번째 index 위치의 데이터 값을 의미
value = array1[2]
print('value:',value)
print(type(value))

-------------------
array1: [1 2 3 4 5 6 7 8 9]
value: 3
<class 'numpy.int64'>

```

단일 인덱싱 특징. value를 추출할 때 차원에 -1


```python
print('맨 뒤의 값:',array1[-1], ', 맨 뒤에서 두번째 값:',array1[-2])

---------
맨 뒤의 값: 9 , 맨 뒤에서 두번째 값: 8

```

맨 뒤 인덱스 -1을 자주 사용함. 
맨 앞은 무조건 0, 맨 뒤는 원소 count에 따라 달라져.
그래서 -1로 쉽게 가져온다.

#### 단일 값 추출 2d
axis1은 열
axis0은 행
```python
array2d[0,0] = 1
array2d[0,1] = 2
array2d[1,0] = 4
array2d[2,2] = 9
```

![[attaches/Pasted image 20250728160747.png]]


```python
    array1d = np.arange(start=1, stop=10)
    array2d = array1d.reshape(3,3)
    print(array2d)
    print('(row=0,col=0) index 가리키는 값:', array2d[0,0] )
    print('(row=0,col=1) index 가리키는 값:', array2d[0,1] )
    print('(row=1,col=0) index 가리키는 값:', array2d[1,0] )
    print('(row=2,col=2) index 가리키는 값:', array2d[2,2] )

---------
[[1 2 3]
 [4 5 6]
 [7 8 9]]
(row=0,col=0) index 가리키는 값: 1
(row=0,col=1) index 가리키는 값: 2
(row=1,col=0) index 가리키는 값: 4
(row=2,col=2) index 가리키는 값: 9

```


```python
[[1 2 3]
 [4 5 6]
 [7 8 9]]
(row=0,col=0) index 가리키는 값: 1
(row=0,col=1) index 가리키는 값: 2
(row=1,col=0) index 가리키는 값: 4
(row=2,col=2) index 가리키는 값: 9
array3.shape

----------
array1: [1 2 3 4 5 6 7 8 9]
array3: [1 2 3]
<class 'numpy.ndarray'>
(3,)
```

#### slicing 1d
`:`를 이용하여 연속된 값 선택.

`시작인덱스 : 종료인덱스`

![[attaches/Pasted image 20250728160851.png]]



```python
array1 = np.arange(start=1, stop=10)
# 위치 인덱스 0-2(2포함)까지 추출
array4 = array1[:3]
print(array4)

# 위치 인덱스 3부터 마지막까지 추출
array5 = array1[3:]
print(array5)

# 위치 인덱스로 전체 데이터 추출
array6 = array5[:]
print(array6)


-------------------
[1 2 3]
[4 5 6 7 8 9]
[4 5 6 7 8 9]

```

#### slicing 2d
```
array2d[:2, 0]
```
일 때 앞에는 slicing이고 뒤에는 그냥 단일 값
그래서 1d


![[attaches/Pasted image 20250728161222.png]]


```python
array1d = np.arange(start=1, stop=10)
array2d = array1d.reshape(3,3)
print('array2d:\n',array2d)

print('array2d[0:2, 0:2] \n', array2d[0:2, 0:2])
print('array2d[1:3, 0:3] \n', array2d[1:3, 0:3])
print('array2d[1:3, :] \n', array2d[1:3, :])
print('array2d[:, :] \n', array2d[:, :])
print('array2d[:2, 1:] \n', array2d[:2, 1:])
print('array2d[:2, 0] \n', array2d[:2, 0])


---------------------
array2d:
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
array2d[0:2, 0:2] 
 [[1 2]
 [4 5]]
array2d[1:3, 0:3] 
 [[4 5 6]
 [7 8 9]]
array2d[1:3, :] 
 [[4 5 6]
 [7 8 9]]
array2d[:, :] 
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
array2d[:2, 1:] 
 [[2 3]
 [5 6]]
array2d[:2, 0] 
 [1 4]

```

`array2d[:2, 0] == [1 4]`
마지막에 단일 인덱싱 결과 차원 -1 됨.
다른 값은 2차원에 대해 슬라이싱을 해서 2차원 나옴
2차원에 대해 단일 인덱싱을 했더니 1차원 나옴

```python
print(array2d[0])
print(array2d[1])
print('array2d[0] shape:', array2d[0].shape, 'array2d[1] shape:', array2d[1].shape )


----------------------
[1 2 3]
[4 5 6]
array2d[0] shape: (3,) array2d[1] shape: (3,)

```



#### 팬시 인덱싱 1d
slicing과 유사.
여러 값 추출 can
단 slicing은 **연속된 값**만 가능.
팬시는 **불연속 값** can

```python
array[[2,4,7]]
```

ndarray 뒤에 `[]`브라킷이 나오면 인덱싱 하겠다.
브라킷 안에 ndarray가 나오거나 list가 나오거나.

2, 4, 7의 위치 인덱스를 가지는 값을 추출하라.

![[attaches/Pasted image 20250728161554.png]]





#### 팬시 인덱싱 2d

![[attaches/Pasted image 20250728161703.png]]

```python
array2d[[0,1]] == array2d[[0,1], :]
```
둘이 같다.


```python
array1d = np.arange(start=1, stop=10)
array2d = array1d.reshape(3,3)
print(array2d)

array3 = array2d[[0,1], 2]
print('array2d[[0,1], 2] => ',array3.tolist())

array4 = array2d[[0,1], 0:2]
print('array2d[[0,1], 0:2] => ',array4.tolist())

array5 = array2d[[0,1]]
print('array2d[[0,1]] => ',array5.tolist())



------------------------
[[1 2 3]
 [4 5 6]
 [7 8 9]]
array2d[[0,1], 2] =>  [3, 6]
array2d[[0,1], 0:2] =>  [[1, 2], [4, 5]]
array2d[[0,1]] =>  [[1, 2, 3], [4, 5, 6]]

```



#### 불린 인덱싱
유용
내부적으로는 동일한 방식으로 가져오지만
사용할 때 달라.

이해를 돕기 위한 sudo code
```python
array1d = np.arange(start=1, stop=10)
target = []

for i in range(0, 9):
	if array1d[i] > 5:
		target.append(array1d[i])

array_selected = np.array(target)
-------------
[6 7 8 9]

```

불린 인덱싱 사용 code
```python
array1d = np.aranged(start=0, stop=10)
print(array1d)
array1d[array1d > 5]
print('array1d > 5 불린 인덱싱 결과 값 :', array3)

-------------
[1 2 3 4 5 6 7 8 9]
array1d > 5 불린 인덱싱 결과 값 : [6 7 8 9]

```

브래킷 안에 바로 조건식을 집어넣음.
실제 코드 작성에 가장 많이 사용하게 될 것.




![[attaches/Pasted image 20250728162253.png]]


조건만 실행했을 때 결과
```python
array1d > 5

------------------
array([False, False, False, False, False,  True,  True,  True,  True])

```

조건식의 결과를 boolean 형태로 반환

```python
val = array1d > 5
print(val, type(val), val.shape)

-------------------
[False False False False False  True  True  True  True] <class 'numpy.ndarray'> (9,)
```

위치 인덱스 값을 정하지 않고 bool값만 넣어도 인덱싱이 된다.



```python
boolean_indexes = np.array([False, False, False, False, False,  True,  True,  True,  True])
array3 = array1d[boolean_indexes]
print('불린 인덱스로 필터링 결과 :', array3)

------------------
불린 인덱스로 필터링 결과 : [6 7 8 9]

```

실행해보면 결과가 같음.
자동적으로 false에 해당하는 값의 위치 인덱스를 찾지 않고 true에 해당하는 값의 위치 인덱스만 찾아서 값을 결과에 담아서 반환한다.

bool값을 통해서 인덱스 값을 찾는다.
이것을 기반으로 인덱싱을 수행.


위치 5, 6, 7, 8에 해당하는 값을 팬시 인덱싱으로 가져오는 것과 동일
```python
indexes = np.array([5,6,7,8])
array4 = array1d[ indexes ]
print('일반 인덱스로 필터링 결과 :',array4)
---------------

일반 인덱스로 필터링 결과 : [6 7 8 9]
```

불린 인덱싱 정리.
조건식만 브래킷 안에 넣으면 
true인 위치 인덱스만 찾아서 값을 준다.

![[attaches/Pasted image 20250728165454.png]]

