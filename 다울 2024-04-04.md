]---
title: 다울 2024-04-04
created: 2024-04-04 07:59
aliases: 
tags:
---
- [x] 나스 솔루션 link, source 백업하기 ✅ 2024-04-04
Yesterday: [[다울 2024-04-03]]
Tomorrow: [[다울 2024-04-05]]

## 이번주 작업 목표
- [x] 드래그할 때 마우스 커서 변경으로 인한 오류 해결 ✅ 2024-04-04
- [x] 드래그드롭으로 스케줄 마지막에 일정 넣을 때 2칸으로 계획이 잡히도록 수정 ✅ 2024-04-04
- [x] dragdrop으로 스케줄에 선석이동 ✅ 2024-05-29
- [x] 드래그로 일정 변경 ✅ 2024-05-29
- [x] 드래그로 일정 삭제 ✅ 2024-05-29
[[temp/GiveFeedback 이벤트|GiveFeedback 이벤트]]

디스플레이 유니티 회의

3d 화면은 보완재

스케줄링은 c#
나머지는 3d

```
This exception was originally thrown at this call stack:
    [External Code]
    DW_SDMS.CommSpread.SetCellValue(int, string, string) in SpreadGridManager.cs
    DW_SDMS.up하역작업계획.viewCompareSpreadData() in up하역작업계획.cs
    DW_SDMS.up하역작업계획.DataView() in up하역작업계획.cs
    DW_SDMS.up하역작업계획.up하역작업계획_Load(object, System.EventArgs) in up하역작업계획.cs
    [External Code]
    DW_SDMS.AppStart.AttachPage(string) in AppStart.cs
```

### 에러 처리
gdi+ 에러
드래그 오버해서 마우스를 움직이는 동안 계속 setCursor가 작동하기 때문에 발생한다고 생각함.

dragFeedback에서 setcursor를 뺏더니 안 나는건 아닌데 더 오래 버팀


마우스 다운(MouseDown) 이벤트와 드래그 오버(DragOver) 이벤트에서 커서를 변경했을 때 커서가 깜빡이는 현상은 주로 커서 업데이트가 빈번하게 발생하기 때문에 나타납니다. 이는 특히 드래그 오버 이벤트가 발생할 때마다 커서 설정 코드가 반복 실행되어 발생할 수 있습니다. 여기에는 몇 가지 주요 원인과 해결 방법이 있습니다.


### 배운 것
###### 빈번한 커서 업데이트
드래그 오버 이벤트는 
마우스 포인터가 드래그 대상 위를 움직일 때마다 매우 빈번하게 발생합니다. 
이벤트 핸들러 내에서 커서를 변경하는 코드가 매번 실행되면, 
커서 업데이트 과정에서 짧은 깜빡임이나 지연이 발생할 수 있습니다. 
이는 특히 커서 변경 작업이 시스템 리소스를 상당히 사용할 때 더욱 눈에 띄게 됩니다.

###### 커서 변경 로직 최적화
커서가 깜빡이지 않도록 하려면, 커서 변경 로직을 최적화할 필요가 있습니다. 
예를 들어, 현재 커서 상태를 추적하여 실제로 커서 상태에 변화가 필요할 때만 커서를 업데이트하는 방식으로 로직을 조정할 수 있습니다. 
이는 불필요한 커서 변경 작업을 최소화하여 성능을 향상시키고 깜빡임을 줄일 수 있습니다.

###### 시스템 리소스 사용 최소화
사용자 정의 커서를 로드하고 적용하는 과정에서 발생하는 시스템 리소스의 사용을 최소화하도록 노력합니다. 
예를 들어, 
사용자 정의 커서를 애플리케이션 시작 시 한 번만 로드하여 
메모리에 저장하고, 
드래그 오버 이벤트가 발생할 때마다 이를 재사용하는 방식으로 구현할 수 있습니다.

###### UI 스레드와의 동기화
UI 업데이트와 관련된 작업은 UI 스레드에서 수행되어야 합니다. 
커서 변경 로직이 백그라운드 스레드에서 실행되고 있다면, 
이를 UI 스레드와 올바르게 동기화하여 실행하도록 변경하는 것이 좋습니다. 
이는 `Invoke`나 `BeginInvoke` 같은 메서드를 사용하여 
UI 스레드에서 커서 업데이트 코드를 실행하도록 함으로써 달성할 수 있습니다.

커서가 깜빡이는 문제를 해결하기 위해서는 
이벤트 핸들링 로직과 UI 업데이트 방식을 면밀히 검토하고, 
성능과 사용자 경험을 모두 고려한 최적화 전략을 적용해야 합니다.

Q1 : 커서 상태를 추적하고 관리하는 효율적인 방법은 무엇인가요?
Q2 : 커서 변경 작업을 UI 스레드와 올바르게 동기화하는 방법에는 어떤 것들이 있나요?

커서 상태의 추적과 관리, 
그리고 UI 스레드와의 동기화는 사용자 인터페이스가 효과적으로 반응하고, 
사용자 경험이 부드러워야 하는 모든 애플리케이션에서 중요한 요소입니다. 
여기서는 이러한 작업을 수행하는 방법에 대해 구체적으로 알아보겠습니다.

###### 커서 상태 추적 및 관리
커서 상태를 효과적으로 추적하고 관리하기 위해, 
애플리케이션 내에서 현재 커서의 상태를 나타내는 변수를 유지할 수 있습니다. 
이 변수는 현재 활성화된 커서 타입을 저장하고, 
드래그 오버나 마우스 다운 같은 이벤트가 발생할 때마다 
이 변수의 값을 확인하여 
실제 커서 상태가 변경되어야 할 필요가 있는지를 결정하는 데 사용됩니다. 
커서 상태가 변경될 필요가 있을 때만 커서 업데이트 로직을 실행함으로써, 
불필요한 업데이트를 최소화하고 깜빡임을 줄일 수 있습니다.

예를 들어, 드래그 앤 드롭 작업을 시작하기 전에 `dragInProgress` 같은 불린 변수를 `true`로 설정하고, 작업이 끝나면 `false`로 설정합니다. 이 변수를 사용하여 커서 변경 로직을 조건부로 실행할 수 있습니다.

###### UI 스레드와의 동기화 방법
UI 스레드와의 동기화를 위해 .NET에서는 `Control.Invoke`와 `Control.BeginInvoke` 메서드를 제공합니다. 이 메서드들은 UI 스레드에서 코드를 실행할 수 있게 해주며, 이는 커서 변경과 같은 UI 업데이트가 안전하게 수행되도록 보장합니다.

- `Control.Invoke`: UI 스레드에서 동기적으로 메서드를 실행하며, 해당 메서드가 완료될 때까지 현재 스레드를 차단합니다. UI 업데이트가 작고 빠르게 수행되어야 하는 경우에 적합합니다.
- `Control.BeginInvoke`: UI 스레드에서 비동기적으로 메서드를 실행합니다. 이 방법은 UI 업데이트를 요청하고 즉시 반환하여 현재 작업을 계속 진행할 수 있게 해주므로, UI 반응성이 중요한 상황에서 유용합니다.

이 메서드들을 사용할 때는 대상 컨트롤(예: 폼이나 버튼)에 대한 참조가 필요하며, 이 컨트롤을 통해 UI 업데이트를 스케줄링합니다. 이렇게 하면 백그라운드 작업 중에도 안전하게 UI를 업데이트할 수 있으며, UI 스레드와의 동기화 문제를 효과적으로 해결할 수 있습니다.

이 두 전략을 통해 커서의 깜빡임 없이 부드러운 사용자 경험을 제공하며, 애플리케이션의 성능과 반응성을 개선할 수 있습니다.