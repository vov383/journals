---
title: 다울 2025-07-31
created: 2025-07-31 08:10
aliases: 
tags: [다울일간노트]
---


Yesterday: [[다울 2025-07-30]] 
Tomorrow: [[다울 2025-08-01]] 


## 오늘 작업 목표
- [ ] pms 관련 조회, 입력, 수정, 삭제 기능 프로젝트 구현
	- [ ] 프로젝트관리 조회화면
		- [ ] 입력, 수정 화면으로 전환. 더블클릭 이벤트
		- [ ] 조회 조건 계약기간
		- [ ] 계약처
		- [ ] 원청사
		- [ ] 사업부
	- [ ] 코드 관리
		- [ ] 계약처
		- [ ] 원청
		- [ ] 사업부_
	- [ ] 설정 화면
		- [ ] 직원 리스트
		- [ ] 계약처 목록
		- [ ] 원청사 목록


CONTRACT_NUM
CONTRACT_NAME
CONTRACT_PRICE
CONTRACT_SDATE
CONTRACT_EDATE
CORP1_NUM
CORP2_NUM
REMARKS
PMS_PART
DT_INSERT
DT_UPDATE


설정. 직원 정보 등록, 수정, 삭제
설정. 원청사, 계약사 정보 등록, 수정, 삭제
프로젝트 관리. PMS 조회

설정. 직원 정보 등록, 수정, 삭제
설정. 원청사, 계약사 정보 등록, 수정, 삭제
프로젝트 관리. PMS 조회
회원 비밀번호 변경 기능

## Not done yet

```dataviewjs

dv.taskList(dv.pages('-"3. Resource/Templates"').file.tasks

.where(t => !t.completed && !t.text.includes("@frank") &&

!t.text.includes("#task")

))

```

---

## 배운 것




## 정리가 필요한 메모는 아래에


유니티에서 DI(의존성 주입) 프레임워크 사용이 과연 실용적인가

해당 토론은 **"유니티에서 DI(의존성 주입) 프레임워크 사용이 과연 실용적인가?"** 라는 주제를 중심으로, DI에 대한 비판적인 시각과 이를 옹호하는 시각이 대립하는 양상을 보입니다.

### 글쓴이의 핵심 주장: "DI는 유니티에서 불필요하며, 오히려 비효율적이다"

글쓴이는 DI 프레임워크(예: Zenject)가 유니티 개발 환경의 특수성을 무시한 과잉 설계(Over-engineering)라고 비판합니다. 주장의 근거는 다음과 같습니다.

1. **유니티는 이미 자체적인 DI 수단을 제공한다:**
    
    - **인스펙터(Inspector):** 컴포넌트의 public 필드에 다른 오브젝트를 드래그 앤 드롭하는 것 자체가 가장 직관적인 형태의 **시각적 의존성 주입(Visual DI)**이다.
        
    - **`GetComponent<T>()`:** 코드 내에서 필요한 의존 대상을 동적으로 찾는 **서비스 로케이터(Service Locator)** 패턴의 역할을 이미 수행하고 있다.
        
2. **DI 프레임워크는 부자연스러운 흐름을 강요한다:**
    
    - 유니티는 컴포넌트 기반(Component-Based) 설계를 근간으로 하는데, 외부 라이브러리인 DI 프레임워크는 이와 이질적인 전통적인 객체 지향(OOP)의 생명주기 관리 방식을 강요한다.
        
    - 이로 인해 불필요한 보일러플레이트(Boilerplate, 반복적인 상용구 코드)가 증가하고, 코드의 흐름을 파악하기 어렵게 만들어 오히려 복잡성만 키운다.
        

**요약:** 글쓴이는 "유니티의 방식을 따르는 것(인스펙터, `GetComponent`)이 더 단순하고 효율적인데, 굳이 외부 도구를 가져와 복잡성을 늘릴 필요가 없다"고 주장합니다.

### 답변(댓글)의 반론 및 다른 관점: "DI는 특정 문제를 해결하는 강력한 도구다"

댓글에서는 글쓴이의 주장에 동의하는 의견도 일부 있지만, 대부분 DI의 필요성을 강조하며 글쓴이의 주장을 반박합니다. 반론의 핵심 근거는 다음과 같습니다.

1. **테스트 용이성(Testability)의 압도적인 이점:**
    
    - `GetComponent`나 인스펙터에 의존하는 코드는 유니티 에디터 환경 없이는 독립적인 **단위 테스트(Unit Test)가 거의 불가능**하다.
        
    - DI를 사용하면, 실제 컴포넌트 대신 가짜 객체(Mock)를 쉽게 주입하여 순수한 로직만을 분리해 테스트할 수 있다. 이는 프로젝트의 안정성과 신뢰도를 높이는 데 결정적이다.
        
2. **확장성과 유지보수의 차이:**
    
    - **"인스펙터 지옥(Inspector Hell)":** 프로젝트 규모가 커지면, 수십, 수백 개의 프리팹에 연결된 의존성을 일일이 손으로 관리하는 것은 재앙에 가깝다. 예를 들어 저장 방식을 `LocalSave`에서 `CloudSave`로 변경할 때, DI를 쓰면 설정 코드 한 줄만 바꾸면 되지만, 인스펙터 방식은 모든 관련 프리팹을 찾아 수정해야 한다.
        
    - DI는 **의존성 관리를 중앙화**하여, 이러한 변경에 유연하고 신속하게 대응할 수 있게 한다.
        
3. **진정한 디커플링(Decoupling, 결합도 낮추기):**
    
    - 인스펙터 방식은 '구체적인 실제 객체'에 직접 의존하지만, DI는 '추상적인 역할(인터페이스)'에 의존한다. 이 추상화 계층 덕분에 부품을 갈아 끼우듯 기능을 쉽게 교체하거나 확장할 수 있는 유연성이 생긴다.
        

### 종합 정리: 관점의 차이는 어디에서 오는가?

이 논쟁의 핵심은 **"무엇을 더 중요하게 생각하는가"**의 관점 차이에서 비롯됩니다.

- **글쓴이의 관점:** **개발 속도와 직관성, 유니티 본연의 워크플로우**를 우선시합니다. 이는 프로토타이핑, 소규모 프로젝트, 1인 개발 환경에서 매우 설득력 있는 주장입니다. 당장의 복잡성을 줄이고 빠르게 결과물을 만드는 데 유리하기 때문입니다.
    
- **반론의 관점:** **장기적인 안정성, 테스트 가능성, 대규모 프로젝트에서의 유지보수성**을 우선시합니다. 이는 여러 사람이 협업하거나, 수년에 걸쳐 서비스를 유지보수해야 하는 상용 프로젝트에서 필수적으로 고려해야 할 요소입니다.
    

결론적으로, 이 토론은 DI라는 도구 자체가 좋고 나쁨을 따지는 것이라기보다는, **프로젝트의 규모, 기간, 팀의 구성, 그리고 개발의 지향점(속도 vs 안정성)에 따라 도구의 유효성이 달라진다**는 사실을 보여주는 좋은 예시라고 할 수 있습니다.
