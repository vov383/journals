---
title: 다울 2024-05-22
created: 2024-05-22 08:05
aliases: 
tags:
---
- [x] 나스 솔루션 link, source 백업하기 ✅ 2024-05-22
Yesterday: [[다울 2024-05-21]]
Tomorrow: [[다울 2024-05-23]]

## 오늘 작업 목표
- [x] 선박 목록 조회 시 작업 시간 계산 ✅ 2024-05-22
- [x] 선석계획 등록 시 작업 길이 자동 계산 ✅ 2024-05-22
- [ ] 선석계획 셀배경색 변경.
- [ ] 선석확정(order)은 텍스트를 bold표시, 선석계획(plan)은 일반 표시



해송적치계획 화면 새로 만들기


```cs
BerthCommon.SafeConvertToBoolean(dict2["isDecisioned"])
```



Nullable in CSharp
### `?`와 `??` 연산자 이해하기

#### 1. `?` (Nullable 형식)
C#에서 `?`는 nullable 형식을 나타내는 데 사용됩니다. 
이는 해당 변수에 null 값을 할당할 수 있게 해줍니다. 
주로 값 형식(value type)에서 사용됩니다.

예를 들어:
```csharp
int? nullableInt = null;
nullableInt = 5;
```

위의 코드에서 `int?`는 `Nullable<int>`를 의미합니다. 
즉, `nullableInt`는 정수값이나 `null`을 가질 수 있습니다.

null 병합 연산자 in CSharp
#### 2. `??` (null 병합 연산자)
`??` 연산자는 null 병합 연산자(null-coalescing operator)라고 불립니다. 
이 연산자는 왼쪽 피연산자가 `null`이 아닌 경우 그 값을 반환하고,
`null`인 경우 오른쪽 피연산자의 값을 반환합니다.

예를 들어:
```csharp
int? nullableInt = null;
int nonNullableInt = nullableInt ?? 10; // nullableInt가 null이므로 10을 반환
```

위의 코드에서 `nullableInt`가 `null`이기 때문에 `nonNullableInt`는 `10`이 됩니다. 
만약 `nullableInt`가 `null`이 아닌 값(예: 5)을 가지면, `nonNullableInt`는 그 값을 갖습니다.

### 예제 코드
```csharp
// Nullable 형식
int? nullableValue = null;
if (nullableValue.HasValue)
{
    Console.WriteLine($"Value is {nullableValue.Value}");
}
else
{
    Console.WriteLine("Value is null");
}

// Null 병합 연산자
int? value1 = null;
int? value2 = 10;
int result1 = value1 ?? 5; // value1이 null이므로 5를 반환
int result2 = value2 ?? 5; // value2가 null이 아니므로 10을 반환

Console.WriteLine($"result1: {result1}"); // result1: 5
Console.WriteLine($"result2: {result2}"); // result2: 10
```

### 요약

######  (Nullable 형식
값 형식에 대해 null을 허용합니다. 
	예: `int?`, `double?`.
######  (null 병합 연산자
왼쪽 피연산자가 null인 경우 오른쪽 피연산자를 반환합니다. 
	예: `nullableInt ?? 10`.

Q1: Nullable 형식을 사용하는 이유는 무엇인가요?  
Q2: null 병합 연산자를 사용하면 코드의 가독성과 유지보수성에 어떤 장점이 있을까요?



한 번의 LINQ 쿼리로 `MOVE` 값의 존재 여부와 `MAKETYPE` 값에 따라 데이터를 네 개의 그룹으로 나누기 위해서는, `GroupBy`를 두 개의 조건으로 사용할 수 있습니다. 

아래는 그 예제 코드입니다:

```csharp
var groupedLists = ds.Tables[0]
    .AsEnumerable()
    .GroupBy(row => new 
    { 
        IsMoveEmpty = string.IsNullOrEmpty($"{row["MOVE"]}"), 
        MakeType = $"{row["MAKETYPE"]}" 
    })
    .Select(g => new
    {
        g.Key.IsMoveEmpty,
        g.Key.MakeType,
        Rows = g.Select(row => row.Table.Columns
            .Cast<DataColumn>()
            .ToDictionary(
                col => col.ColumnName,
                col => row[col])
        )
        .OrderBy(row => row["DT_START"])
        .ToList()
    })
    .ToList();

var notMovedMakeType0 = groupedLists
    .FirstOrDefault(g => g.IsMoveEmpty == true && g.MakeType == "0")?.Rows ?? new List<Dictionary<string, object>>();

var notMovedMakeType1 = groupedLists
    .FirstOrDefault(g => g.IsMoveEmpty == true && g.MakeType == "1")?.Rows ?? new List<Dictionary<string, object>>();

var movedMakeType0 = groupedLists
    .FirstOrDefault(g => g.IsMoveEmpty == false && g.MakeType == "0")?.Rows ?? new List<Dictionary<string, object>>();

var movedMakeType1 = groupedLists
    .FirstOrDefault(g => g.IsMoveEmpty == false && g.MakeType == "1")?.Rows ?? new List<Dictionary<string, object>>();
```

### 코드 설명

1. **GroupBy**: `MOVE` 값의 존재 여부 (`IsMoveEmpty`)와 `MAKETYPE` 값 (`MakeType`)을 기준으로 데이터를 그룹화합니다.
2. **Select**: 각 그룹에 대해 딕셔너리 형태로 변환하고, `DT_START` 컬럼을 기준으로 정렬합니다.
3. **groupedLists**: 그룹화된 리스트를 저장합니다.
4. **notMovedMakeType0**: `MOVE`가 비어있고 `MAKETYPE`이 0인 그룹을 선택하여 리스트를 생성합니다.
5. **notMovedMakeType1**: `MOVE`가 비어있고 `MAKETYPE`이 1인 그룹을 선택하여 리스트를 생성합니다.
6. **movedMakeType0**: `MOVE`가 비어있지 않고 `MAKETYPE`이 0인 그룹을 선택하여 리스트를 생성합니다.
7. **movedMakeType1**: `MOVE`가 비어있지 않고 `MAKETYPE`이 1인 그룹을 선택하여 리스트를 생성합니다.

### 요약

1. `GroupBy`를 사용하여 `MOVE` 값의 존재 여부와 `MAKETYPE` 값에 따라 그룹화합니다.
2. 각 그룹을 딕셔너리 형태로 변환하고 정렬합니다.
3. 그룹화된 리스트에서 네 개의 하위 리스트를 추출합니다: `notMovedMakeType0`, `notMovedMakeType1`, `movedMakeType0`, `movedMakeType1`.

Q1: GroupBy를 사용하여 여러 조건으로 데이터를 그룹화할 때 주의해야 할 점은 무엇인가요?  
Q2: 데이터 그룹화 후 각 그룹을 처리할 때 발생할 수 있는 잠재적인 문제는 무엇인가요?



```sql
{ INSERT INTO TB_DOCK_ORDER2 (  DW_SEQ  , DT_START  , SHIFT_START  , DT_END  , SHIFT_END  , MW_CD  , MW_NM  , MOVE  , DT_START2  , SHIFT_START2  , DT_END2  , SHIFT_END2  , MW_CD2  , MW_NM2  , SH_CD  , SH_NM  , SH_YEAR  , SH_CHASU  , DT_DW_START  , DT_DW_END  , DW_TIME  , MONEY_EXPENSE  , EFFICIENT_INDEX  , MAKE_TYPE  , DECISION  , DT_INSERT  ) VALUES (  '102'  , '20240520'  , 'A'  , '20240521'  , 'B'  , 'MW02'  , '2선석'  , '0'  , ''  , ''  , ''  , ''  , ''  , ''  , 'ACE'  , 'Giant Ace'  , '2023'  , '1'  , ''  , ''  , ''  , ''  , ''  , '0'  , '1'  , NOW()  ) }

{ INSERT INTO TB_DOCK_ORDER2 (  DW_SEQ  , DT_START  , SHIFT_START  , DT_END  , SHIFT_END  , MW_CD  , MW_NM  , MOVE  , DT_START2  , SHIFT_START2  , DT_END2  , SHIFT_END2  , MW_CD2  , MW_NM2  , SH_CD  , SH_NM  , SH_YEAR  , SH_CHASU  , DT_DW_START  , DT_DW_END  , DW_TIME  , MONEY_EXPENSE  , EFFICIENT_INDEX  , MAKE_TYPE  , DECISION  , DT_INSERT  ) VALUES (  '102'  , '20240520'  , 'A'  , '20240521'  , 'B'  , 'MW02'  , '2선석'  , '0'  , ''  , ''  , ''  , ''  , ''  , ''  , 'ACE'  , 'Giant Ace'  , '2023'  , '1'  , ''  , ''  , ''  , ''  , ''  , '0'  , '1'  , NOW()  ) }

```